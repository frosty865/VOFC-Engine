/**
 * Run migration to add structured vulnerability columns to submission_vulnerabilities table
 * This adds: question, what, so_what, sector, subsector, discipline columns
 */

const { createClient } = require('@supabase/supabase-js')
const fs = require('fs').promises
const path = require('path')
require('dotenv').config({ path: path.join(__dirname, '../vofc-viewer/.env.local') })

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL
const SUPABASE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_SERVICE_KEY

if (!SUPABASE_URL || !SUPABASE_KEY) {
  console.error('âŒ Missing Supabase credentials')
  console.error('   Set NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY')
  process.exit(1)
}

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

// SQL migration statements
const migrationSQL = `
-- Add structured vulnerability columns if they don't exist
DO $$
BEGIN
  -- Add question column
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' AND table_name = 'submission_vulnerabilities' AND column_name = 'question'
  ) THEN
    ALTER TABLE public.submission_vulnerabilities ADD COLUMN question text;
    COMMENT ON COLUMN public.submission_vulnerabilities.question IS 'Assessment question in proper question format (e.g., "Are there adequate...?")';
  END IF;

  -- Add what column
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' AND table_name = 'submission_vulnerabilities' AND column_name = 'what'
  ) THEN
    ALTER TABLE public.submission_vulnerabilities ADD COLUMN what text;
    COMMENT ON COLUMN public.submission_vulnerabilities.what IS 'Clear description of the vulnerability in sentence format';
  END IF;

  -- Add so_what column
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' AND table_name = 'submission_vulnerabilities' AND column_name = 'so_what'
  ) THEN
    ALTER TABLE public.submission_vulnerabilities ADD COLUMN so_what text;
    COMMENT ON COLUMN public.submission_vulnerabilities.so_what IS 'Impact, consequence, or risk if this vulnerability is not addressed';
  END IF;

  -- Add sector column
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' AND table_name = 'submission_vulnerabilities' AND column_name = 'sector'
  ) THEN
    ALTER TABLE public.submission_vulnerabilities ADD COLUMN sector varchar(256);
    COMMENT ON COLUMN public.submission_vulnerabilities.sector IS 'Primary sector (e.g., Education, Healthcare, Energy, Government Facilities, Transportation, Water)';
  END IF;

  -- Add subsector column
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' AND table_name = 'submission_vulnerabilities' AND column_name = 'subsector'
  ) THEN
    ALTER TABLE public.submission_vulnerabilities ADD COLUMN subsector varchar(256);
    COMMENT ON COLUMN public.submission_vulnerabilities.subsector IS 'Specific subsector within the sector';
  END IF;

  -- Add discipline column
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' AND table_name = 'submission_vulnerabilities' AND column_name = 'discipline'
  ) THEN
    ALTER TABLE public.submission_vulnerabilities ADD COLUMN discipline varchar(256);
    COMMENT ON COLUMN public.submission_vulnerabilities.discipline IS 'Security discipline (Security Management, Physical Security, Entry Controls, VSS, Security Force, Information Sharing, Resilience, Training)';
  END IF;
END $$;

-- Create indexes if they don't exist
CREATE INDEX IF NOT EXISTS idx_submission_vulnerabilities_sector ON public.submission_vulnerabilities(sector);
CREATE INDEX IF NOT EXISTS idx_submission_vulnerabilities_subsector ON public.submission_vulnerabilities(subsector);
CREATE INDEX IF NOT EXISTS idx_submission_vulnerabilities_discipline ON public.submission_vulnerabilities(discipline) WHERE discipline IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_submission_vulnerabilities_question ON public.submission_vulnerabilities USING gin(to_tsvector('english', question)) WHERE question IS NOT NULL;
`

async function runMigration() {
  try {
    console.log('ğŸ”§ Running migration to add structured vulnerability columns...\n')
    
    // Execute migration using Supabase RPC (if available) or direct SQL
    // Note: Supabase doesn't expose exec directly, so we'll use the REST API
    // For production, you should run this SQL directly in Supabase dashboard or via psql
    
    console.log('ğŸ“ Migration SQL:')
    console.log(migrationSQL)
    console.log('\nâš ï¸  Supabase REST API cannot execute arbitrary SQL.')
    console.log('   Please run this SQL in your Supabase dashboard:')
    console.log('   1. Go to SQL Editor in Supabase dashboard')
    console.log('   2. Paste the SQL above')
    console.log('   3. Execute the migration\n')
    
    // Alternative: Try to use pg_stat_statements or check column existence
    console.log('ğŸ” Checking current schema...\n')
    
    // Check which columns exist by trying to query them
    const { data: testData, error: testError } = await supabase
      .from('submission_vulnerabilities')
      .select('id, question, what, so_what, sector, subsector, discipline')
      .limit(1)
    
    if (testError) {
      if (testError.code === 'PGRST116' || testError.message.includes('column') || testError.message.includes('schema cache')) {
        console.log('âŒ Missing columns detected. Migration is required.\n')
        console.log('ğŸ“‹ Copy and paste this SQL into Supabase SQL Editor:\n')
        console.log('='.repeat(80))
        console.log(migrationSQL)
        console.log('='.repeat(80))
        return
      }
    } else {
      console.log('âœ… All columns appear to exist already!')
      console.log('   Schema is up to date.\n')
      return
    }
    
  } catch (error) {
    console.error('âŒ Migration check failed:', error.message)
    console.log('\nğŸ“‹ Copy and paste this SQL into Supabase SQL Editor:\n')
    console.log('='.repeat(80))
    console.log(migrationSQL)
    console.log('='.repeat(80))
    process.exit(1)
  }
}

runMigration()
  .then(() => {
    console.log('\nâœ… Migration check complete')
    process.exit(0)
  })
  .catch((error) => {
    console.error('âŒ Migration failed:', error)
    process.exit(1)
  })

