import { NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

/**
 * Approve or reject a single vulnerability from a submission
 * Checks for duplicates before inserting
 */
function normalizeText(text) {
  if (!text) return '';
  return text
    .toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function calculateSimilarity(text1, text2) {
  const norm1 = normalizeText(text1);
  const norm2 = normalizeText(text2);
  
  if (!norm1 || !norm2) return 0;
  if (norm1 === norm2) return 1;
  
  const tokens1 = new Set(norm1.split(' ').filter(w => w.length > 2));
  const tokens2 = new Set(norm2.split(' ').filter(w => w.length > 2));
  
  if (tokens1.size === 0 || tokens2.size === 0) return 0;
  
  const intersection = new Set([...tokens1].filter(t => tokens2.has(t)));
  const union = new Set([...tokens1, ...tokens2]);
  
  return intersection.size / union.size;
}

export async function POST(request, { params }) {
  try {
    const { id: submissionId } = await params;
    const body = await request.json();
    const { vulnerability, action, linkedOfcs } = body; // action: 'approve' or 'reject'
    
    if (!vulnerability || !action) {
      return NextResponse.json({ error: 'Missing vulnerability or action' }, { status: 400 });
    }
    
    // Load submission to get context
    const { data: submission, error: subErr } = await supabase
      .from('submissions')
      .select('data, status')
      .eq('id', submissionId)
      .single();
    
    if (subErr || !submission) {
      return NextResponse.json({ error: 'Submission not found' }, { status: 404 });
    }
    
    if (action === 'approve') {
      // Check for duplicate vulnerability
      const vulnText = `${vulnerability.title || vulnerability.vulnerability || ''} ${vulnerability.description || ''}`.trim();
      
      const { data: existingVulns } = await supabase
        .from('submission_vulnerabilities')
        .select('id, title, description');
      
      let isDuplicate = false;
      let duplicateVuln = null;
      
      if (existingVulns) {
        for (const existing of existingVulns) {
          const existingText = `${existing.title || ''} ${existing.description || ''}`.trim();
          const similarity = calculateSimilarity(vulnText, existingText);
          
          if (similarity >= 0.7) {
            isDuplicate = true;
            duplicateVuln = existing;
            break;
          }
        }
      }
      
      if (isDuplicate) {
        // Mark as duplicate - don't insert, but return info
        return NextResponse.json({
          success: true,
          duplicate: true,
          message: 'Duplicate vulnerability detected',
          existing_vulnerability: duplicateVuln,
          action: 'skipped'
        });
      }
      
      // Insert vulnerability (not a duplicate)
      // Build description from structured fields
      // Structure: Question -> Vulnerability Statement (Answer) -> What/So What
      const parts = [];
      
      // 1. Assessment Question (required)
      if (vulnerability.question) {
        parts.push(`Assessment Question: ${vulnerability.question}`);
      }
      
      // 2. Vulnerability Statement (answer to the question)
      // Use vulnerability.vulnerability or vulnerability.title (NOT vulnerability_text)
      const vulnStatement = vulnerability.vulnerability || vulnerability.title || '';
      if (vulnStatement) {
        parts.push(`Vulnerability Statement: ${vulnStatement}`);
      }
      
      // 3. What/So What (additional context)
      if (vulnerability.what) parts.push(`What: ${vulnerability.what}`);
      if (vulnerability.so_what) parts.push(`So What: ${vulnerability.so_what}`);
      
      let vulnerabilityText = parts.length > 0 ? parts.join('\n\n') : '';
      
      // Build insert payload - schema has 'vulnerability' (NOT NULL), 'title', and 'description'
      // Use vulnerability for the statement, title as alias, description for full text
      const insertPayload = {
        submission_id: submissionId,
        vulnerability: vulnStatement, // Required NOT NULL column
        title: vulnStatement, // Also set title for consistency
        description: vulnerabilityText || vulnerability.description || vulnerability.what || '',
        category: vulnerability.category || null,
        severity: vulnerability.severity || null
      };
      
      // Only add structured fields if they exist (they may not be in the schema yet)
      // These fields require the migration script to be run first
      // We'll check if they exist by trying a safe insert
      const structuredFields = {
        question: vulnerability.question,
        what: vulnerability.what,
        so_what: vulnerability.so_what,
        sector: vulnerability.sector,
        subsector: vulnerability.subsector,
        discipline: vulnerability.discipline
      };
      
      // Add structured fields to payload (will be ignored if columns don't exist)
      // But first, let's try to insert without them to avoid errors
      const { data: insertedVuln, error: vulnErr } = await supabase
        .from('submission_vulnerabilities')
        .insert(insertPayload)
        .select()
        .single();
      
      // If insert succeeded but we have structured fields, try to update them
      // This is a workaround - the proper solution is to run the migration
      if (insertedVuln && !vulnErr && Object.values(structuredFields).some(v => v)) {
        const updatePayload = {};
        Object.entries(structuredFields).forEach(([key, value]) => {
          if (value) updatePayload[key] = value;
        });
        
        if (Object.keys(updatePayload).length > 0) {
          // Try to update with structured fields (will fail silently if columns don't exist)
          await supabase
            .from('submission_vulnerabilities')
            .update(updatePayload)
            .eq('id', insertedVuln.id)
            .then(({ error }) => {
              if (error && error.code !== 'PGRST116') {
                // PGRST116 = column doesn't exist, which is expected if migration hasn't run
                console.warn('Could not update structured fields (columns may not exist):', error.message);
              }
            });
        }
      }
      
      if (vulnErr) {
        console.error('Error inserting vulnerability:', vulnErr);
        throw vulnErr;
      }
      
      // Insert linked OFCs (checking for duplicates first)
      let ofcsInserted = 0;
      let ofcsDuplicates = 0;
      
      if (linkedOfcs && Array.isArray(linkedOfcs) && linkedOfcs.length > 0) {
        const { data: existingOfcs } = await supabase
          .from('submission_options_for_consideration')
          .select('id, title, description');
        
        for (const ofc of linkedOfcs) {
          const ofcText = `${ofc.title || ofc.option || ''} ${ofc.description || ''}`.trim();
          
          // Check for duplicate OFC
          let isOfcDuplicate = false;
          if (existingOfcs) {
            for (const existing of existingOfcs) {
              const existingText = `${existing.title || ''} ${existing.description || ''}`.trim();
              if (calculateSimilarity(ofcText, existingText) >= 0.7) {
                isOfcDuplicate = true;
                break;
              }
            }
          }
          
          if (!isOfcDuplicate) {
            // Insert OFC
            await supabase
              .from('submission_options_for_consideration')
              .insert({
                submission_id: submissionId,
                title: ofc.title || ofc.option,
                description: ofc.description || '',
                linked_vulnerability: insertedVuln.id
              });
            ofcsInserted++;
          } else {
            ofcsDuplicates++;
          }
        }
      }
      
      // Create learning event
      await supabase
        .from('learning_events')
        .insert({
          submission_id: submissionId,
          event_type: 'approval',
          approved: true,
          model_version: process.env.OLLAMA_MODEL || 'vofc-engine:latest',
          confidence_score: 1.0,
          metadata: JSON.stringify({
            vulnerability_id: insertedVuln.id,
            vulnerability: vulnerability.title || vulnerability.vulnerability,
            ofc_count: ofcsInserted
          })
        });
      
      return NextResponse.json({
        success: true,
        duplicate: false,
        vulnerability: insertedVuln,
        ofcs_inserted: ofcsInserted,
        ofcs_duplicates: ofcsDuplicates,
        message: `Vulnerability approved. ${ofcsInserted} OFCs added, ${ofcsDuplicates} duplicates skipped.`
      });
      
    } else if (action === 'reject') {
      // Just mark as rejected (no DB insert needed)
      return NextResponse.json({
        success: true,
        message: 'Vulnerability rejected',
        action: 'rejected'
      });
    } else {
      return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
    }
    
  } catch (e) {
    console.error('Error in approve-vulnerability:', e);
    return NextResponse.json({ error: e.message }, { status: 500 });
  }
}

