import { NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

/**
 * Approve or reject a single vulnerability from a submission
 * Checks for duplicates before inserting
 */
function normalizeText(text) {
  if (!text) return '';
  return text
    .toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function calculateSimilarity(text1, text2) {
  const norm1 = normalizeText(text1);
  const norm2 = normalizeText(text2);
  
  if (!norm1 || !norm2) return 0;
  if (norm1 === norm2) return 1;
  
  const tokens1 = new Set(norm1.split(' ').filter(w => w.length > 2));
  const tokens2 = new Set(norm2.split(' ').filter(w => w.length > 2));
  
  if (tokens1.size === 0 || tokens2.size === 0) return 0;
  
  const intersection = new Set([...tokens1].filter(t => tokens2.has(t)));
  const union = new Set([...tokens1, ...tokens2]);
  
  return intersection.size / union.size;
}

export async function POST(request, { params }) {
  try {
    const { id: submissionId } = await params;
    const body = await request.json();
    const { vulnerability, action, linkedOfcs } = body; // action: 'approve' or 'reject'
    
    if (!vulnerability || !action) {
      return NextResponse.json({ error: 'Missing vulnerability or action' }, { status: 400 });
    }
    
    // Load submission to get context
    const { data: submission, error: subErr } = await supabase
      .from('submissions')
      .select('data, status')
      .eq('id', submissionId)
      .single();
    
    if (subErr || !submission) {
      return NextResponse.json({ error: 'Submission not found' }, { status: 404 });
    }
    
    if (action === 'approve') {
      // Check for duplicate vulnerability
      const vulnText = `${vulnerability.title || vulnerability.vulnerability || ''} ${vulnerability.description || ''}`.trim();
      
      const { data: existingVulns } = await supabase
        .from('submission_vulnerabilities')
        .select('id, title, description');
      
      let isDuplicate = false;
      let duplicateVuln = null;
      
      if (existingVulns) {
        for (const existing of existingVulns) {
          const existingText = `${existing.title || ''} ${existing.description || ''}`.trim();
          const similarity = calculateSimilarity(vulnText, existingText);
          
          if (similarity >= 0.7) {
            isDuplicate = true;
            duplicateVuln = existing;
            break;
          }
        }
      }
      
      if (isDuplicate) {
        // Mark as duplicate - don't insert, but return info
        return NextResponse.json({
          success: true,
          duplicate: true,
          message: 'Duplicate vulnerability detected',
          existing_vulnerability: duplicateVuln,
          action: 'skipped'
        });
      }
      
      // Insert vulnerability (not a duplicate)
      const { data: insertedVuln, error: vulnErr } = await supabase
        .from('submission_vulnerabilities')
        .insert({
          submission_id: submissionId,
          title: vulnerability.title || vulnerability.vulnerability,
          description: vulnerability.description || '',
          question: vulnerability.question || null,
          what: vulnerability.what || null,
          so_what: vulnerability.so_what || null,
          sector: vulnerability.sector || null,
          subsector: vulnerability.subsector || null,
          discipline: vulnerability.discipline || null,
          category: vulnerability.category || 'General',
          severity: vulnerability.severity || 'Unspecified'
        })
        .select()
        .single();
      
      if (vulnErr) {
        console.error('Error inserting vulnerability:', vulnErr);
        throw vulnErr;
      }
      
      // Insert linked OFCs (checking for duplicates first)
      let ofcsInserted = 0;
      let ofcsDuplicates = 0;
      
      if (linkedOfcs && Array.isArray(linkedOfcs) && linkedOfcs.length > 0) {
        const { data: existingOfcs } = await supabase
          .from('submission_options_for_consideration')
          .select('id, title, description');
        
        for (const ofc of linkedOfcs) {
          const ofcText = `${ofc.title || ofc.option || ''} ${ofc.description || ''}`.trim();
          
          // Check for duplicate OFC
          let isOfcDuplicate = false;
          if (existingOfcs) {
            for (const existing of existingOfcs) {
              const existingText = `${existing.title || ''} ${existing.description || ''}`.trim();
              if (calculateSimilarity(ofcText, existingText) >= 0.7) {
                isOfcDuplicate = true;
                break;
              }
            }
          }
          
          if (!isOfcDuplicate) {
            // Insert OFC
            await supabase
              .from('submission_options_for_consideration')
              .insert({
                submission_id: submissionId,
                title: ofc.title || ofc.option,
                description: ofc.description || '',
                linked_vulnerability: insertedVuln.id
              });
            ofcsInserted++;
          } else {
            ofcsDuplicates++;
          }
        }
      }
      
      // Create learning event
      await supabase
        .from('learning_events')
        .insert({
          submission_id: submissionId,
          event_type: 'approval',
          approved: true,
          model_version: process.env.OLLAMA_MODEL || 'vofc-engine:latest',
          confidence_score: 1.0,
          metadata: JSON.stringify({
            vulnerability_id: insertedVuln.id,
            vulnerability: vulnerability.title || vulnerability.vulnerability,
            ofc_count: ofcsInserted
          })
        });
      
      return NextResponse.json({
        success: true,
        duplicate: false,
        vulnerability: insertedVuln,
        ofcs_inserted: ofcsInserted,
        ofcs_duplicates: ofcsDuplicates,
        message: `Vulnerability approved. ${ofcsInserted} OFCs added, ${ofcsDuplicates} duplicates skipped.`
      });
      
    } else if (action === 'reject') {
      // Just mark as rejected (no DB insert needed)
      return NextResponse.json({
        success: true,
        message: 'Vulnerability rejected',
        action: 'rejected'
      });
    } else {
      return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
    }
    
  } catch (e) {
    console.error('Error in approve-vulnerability:', e);
    return NextResponse.json({ error: e.message }, { status: 500 });
  }
}

