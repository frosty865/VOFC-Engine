const { createClient } = require('@supabase/supabase-js');
require('dotenv').config({ path: '.env.local' });

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
);

async function createVulnerabilityOFCLinks() {
  console.log('ğŸ”— Creating vulnerability-OFC links...\n');

  try {
    // Get some vulnerabilities
    const { data: vulnerabilities, error: vulnError } = await supabase
      .from('vulnerabilities')
      .select('id, vulnerability, discipline')
      .limit(10);

    if (vulnError) {
      console.error('âŒ Error fetching vulnerabilities:', vulnError);
      return;
    }

    console.log(`ğŸ“Š Found ${vulnerabilities?.length || 0} vulnerabilities`);

    // Get some OFCs
    const { data: ofcs, error: ofcError } = await supabase
      .from('options_for_consideration')
      .select('id, option_text, discipline')
      .limit(20);

    if (ofcError) {
      console.error('âŒ Error fetching OFCs:', ofcError);
      return;
    }

    console.log(`ğŸ“Š Found ${ofcs?.length || 0} OFCs`);

    if (!vulnerabilities || !ofcs || vulnerabilities.length === 0 || ofcs.length === 0) {
      console.log('âŒ No vulnerabilities or OFCs found to link');
      return;
    }

    // Create some random links between vulnerabilities and OFCs
    const links = [];
    const linkCount = Math.min(15, vulnerabilities.length * 2); // Create up to 15 links

    for (let i = 0; i < linkCount; i++) {
      const randomVuln = vulnerabilities[Math.floor(Math.random() * vulnerabilities.length)];
      const randomOFC = ofcs[Math.floor(Math.random() * ofcs.length)];
      
      links.push({
        vulnerability_id: randomVuln.id,
        ofc_id: randomOFC.id,
        link_type: 'direct',
        confidence_score: 0.8 + Math.random() * 0.2 // Random confidence between 0.8-1.0
      });
    }

    console.log(`ğŸ”— Creating ${links.length} vulnerability-OFC links...`);

    const { data: insertedLinks, error: linkError } = await supabase
      .from('vulnerability_ofc_links')
      .insert(links)
      .select();

    if (linkError) {
      console.error('âŒ Error creating links:', linkError);
      return;
    }

    console.log(`âœ… Successfully created ${insertedLinks?.length || 0} links!`);

    // Verify the links
    const { data: verifyLinks, error: verifyError } = await supabase
      .from('vulnerability_ofc_links')
      .select(`
        *,
        vulnerabilities (
          id,
          vulnerability,
          discipline
        ),
        options_for_consideration (
          id,
          option_text,
          discipline
        )
      `)
      .limit(5);

    if (verifyError) {
      console.error('âŒ Error verifying links:', verifyError);
    } else {
      console.log('\nğŸ“Š Sample links created:');
      verifyLinks?.forEach((link, index) => {
        console.log(`${index + 1}. Vulnerability: "${link.vulnerabilities?.vulnerability?.substring(0, 50)}..."`);
        console.log(`   OFC: "${link.options_for_consideration?.option_text?.substring(0, 50)}..."`);
        console.log(`   Confidence: ${link.confidence_score}`);
        console.log('');
      });
    }

    return true;

  } catch (error) {
    console.error('âŒ Error:', error);
    return false;
  }
}

if (require.main === module) {
  createVulnerabilityOFCLinks()
    .then(success => {
      if (success) {
        console.log('\nğŸ‰ Vulnerability-OFC linking completed successfully!');
      } else {
        console.log('\nâŒ Vulnerability-OFC linking failed.');
      }
      process.exit(success ? 0 : 1);
    })
    .catch(error => {
      console.error('âŒ Script failed:', error);
      process.exit(1);
    });
}

module.exports = { createVulnerabilityOFCLinks };
